<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://unpkg.com/sanitize.css" rel="stylesheet" />
    <link rel="stylesheet" type="text/css" media="all" href="/styles.css" />
    <script src="/prism_highlight.js"></script>
    <link rel="stylesheet" type="text/css" media="all" href="/prism.css" />
    <script src="./slide_mode.js"></script>
    <!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "268f8e8ed1cf4189996214dfee7b9d3e"}'></script><!-- End Cloudflare Web Analytics -->
    <link rel="shortcut icon" type="image/jpg" href="images/htc_favicon.png"/>
    <title>Lists</title>
</head>

<body>
    <div class="container">
        <main class="main-wrapper">
            <div id="prev">← <a href="/htdf_problemsets.html"> How to Design Functions Problem Sets</a></div>
            <div id="home"><a href="/index.html">Index</a></div>
            <div id="next"><a href="/data_directed_design.html">Data Directed Design</a> →</div>
            <article>
                <h1>Lists</h1><h2 id="the_need_for_a_list"><a class="anchor" href="#the_need_for_a_list">#</a>The need for a list</h2><h3>Averaging the price of items in our shopping cart:</h3><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; average-2-price: (Number Number -&gt; Number)
; produce the average price of the 2 given items
(define (average-2-price item1 item2)
    (/ (+ item1 item2) 2))
</code></pre><h3>Why is this average-2-price code not flexible? Because when we want to handle more item prices, we have to: </h3><ol><li>Write a new function: <code>average-{N}-price</code></li><li>Change the purpose</li><li>Change the number of parameters the function takes</li><li>Change the code of the function</li></ol><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; average-3-price: (Number Number Number -&gt; Number)
; produce the average price of the 3 given items
(define (average-3-price item1 item2 item3)
    (/ (+ item1 item2 item3) 3))

; we'd have to create a new function to handle more data?!
; 4
; 5
; ... it gets worse as we add more. It's not sustainable!
; Imagine a 20-100 argument function...
; I wish there was a datatype that can store multiple values</code></pre><p><strong>BUT WAIT!</strong> Structs can store multiple values in 1 type/variable, so let’s try that!</p><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(define-struct cart [item1 item2])
; Cart is (make-cart Number Number)
; interp. each item{n} is its price

; average-cart-price: (Cart -&gt; Number)
; produces the average price of all the items cart holds
(define (average-cart-price ct)
    (/ (+ (cart-item1 ct)
          (cart-item2 ct)) 2))

(define my-cart (make-cart 9 3))
(average-cart-price my-cart)</code></pre><p>We’re getting there! Because the <code>items</code> are now contained within a <code>(make-cart)</code> structure, here’s what we have to change to accomdate for 3 items:</p><ol><li>The data definition</li><li>The function code</li></ol><p>Contrast this to when functions were just taking the item prices as arguments <strong> individually</strong>, we no longer have to write a new function or adjust the number of parameters we take in when we want to process more items, we instead change the data definition cart.</p><p>Even though structs can hold multiple pieces of data, we still run into the same problem, and that is our <code>cart</code> structure is <strong>fixed sized</strong>. It can/must only hold the <strong>amount of items we tell it to <strong>ahead of time</strong> as specificed by the amount of fields: <code>item{n}</code>!</strong> This which is not realistic! In the real world, when you go shopping, you don’t know the amount of items you want to buy, you often figure it out <strong>along the way</strong>. In other words, it can be <strong>arbitrarily long</strong>. The amount of items in a shopping cart can also fluctate between 5-20 as people put things in and out of their shopping cart all the time! If only there was a type of data that is more flexible that grows and shrinks on demand. Drumroll, that’s what lists are for! We’ll learn how to design code such that the <strong>data &amp; function definition won’t need to change</strong>, just the <strong>data</strong> itself, e.g <code>(make-cart 9 2 3 4)</code>.</p><p>Consider our ripple program in 8.07. How many times does the user click? They can click whenever they want, so it’s completely arbitrary! We’ll later expand our ripple program to handle an infinite amount of ripples, and lists will give us the power to do that.</p><h2 id="what_is_a_list?"><a class="anchor" href="#what_is_a_list?">#</a>What is a list?</h2><p><img src="./images/shopping_list.png"/><br/>A list is a <strong>compound value</strong> datatype that can <strong>grow &amp; shrink on demand</strong>. BSL treats a list as a single value that can can <strong>contain other values</strong> inside itself. Imagine a shopping list, you write “milk, eggs, cheese” on a piece of paper, then fold up the paper and put it in your pocket. While it’s folded up, you can think of the list as a single entity. It’s only later, at the store, where you need to go “into” the list and retrieve the individual pieces of information it contains.</p><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">;empty and '() are exactly the same, you can imagine (define empty '())
empty
'()
; imagine '() empty, being an empty piece of paper. A list must exist ON something

; cons: (Any List -&gt; List)
; short for "construct", cons produces a list

; 1 element list: put #false in FRONT of the empty list
(define stuff (cons #false empty))
(define grocceries (cons "eggs" (cons "chips" empty)))
(define numbers-ls (cons 4 (cons 3 (cons 6 empty))))
(define whatever-ls (cons 9 (cons #true (cons "asdf" empty))))
; silly evaluation:
(define op (cons (* 2 4) (cons 3 (cons (string-append "asd" "qw") empty))))

; first: (ListOfAny -&gt; Any)
; produces the first value of the given list (assuming a non-empty list)
(first stuff) ; produces #false
(first grocceries) ; produces "eggs"
(first numbers-ls) ; produces 4

; rest: (ListOfAny -&gt; ListOfAny)
; produces a list with the first element excluded of a non-empty list
(rest stuff) ; produces the empty list
(rest grocceries) ; produces (cons "chips" empty)
(rest numbers-ls) ; produces (cons 3 (cons 6 empty))

; how do you get the 2nd element of a list? Get me "chips" from grocceries
(first (rest numbers-ls))
; what happens if we try to get the 2nd element of a 1 long list?

; how do you get the 3rd element of a list? Get me 6 in the numbers-ls
(first (rest (rest numbers-ls)))
; what happens if we try to get the 3rd element of a 2 long list

; empty?: (Any -&gt; Boolean)
; produces #true if given an empty, #false otherwise
(empty? 123) ; produces #false
(empty? grocceries) ; produces #false
(empty? empty) ; produces #true

; cons?: (Any -&gt; Boolean)
; Determines whether some value is a constructed list. (do not confuse with "cons". 1 letter difference)
(cons? 123) ; #false
(cons? "asdff") ; #false
(cons? empty) ; #false
(cons? (cons 99 empty)) ; #true
(cons? (cons "moo" (cons "peck" empty))) ; #true

; list? (Any -&gt; Boolean)
; produces #true if given an kind of list(empty or cons)
(list? "asdf") ;#false
(list? #true) ;#false
(list? 21) ;#false
(list? (cons 3 empty)) ;#true
(list? empty) ;#true</code></pre><h3>The List data definition</h3><p>Let’s review <code>cons</code> and lists in a little more detail because it looks a bit weird.</p><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; A List is one of:
; - empty
; - (cons Any List)
; interp. represents a list of Any type of data, e.g an arbitrarily long sequence

; cons: (Any List -&gt; List)
; short for "construct", cons produces a list

(define stuff (cons #false empty))
(define grocceries (cons "eggs" (cons "chips" empty)))
(define numbers-ls (cons 4 (cons 3 (cons 6 empty))))</code></pre><p>The <code>List</code> data definition has a self reference, and its why we see this nesting of cons. It’s easy to miss that the 2nd argument <strong>must</strong> be a <code>list</code>, because the data definition is a comment that is easily glanced over. One of the #1 mistakes people make is not obeying the signature, and not having good data definitions that describe what things are. It has to be a list, either the <code>empty '()</code> list, or another cons list. All lists must eventually end with the <code>empty</code> list. It may take a few reads to <strong>interalize</strong> what data definitions are saying about lists.</p><p>Here are some examples of syntactically invalid lists, try and spot the problem and fix them in your editor</p><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(define bag (cons "choclate" (cons "tomato") empty))
(define nums (cons 3 2))</code></pre><p>You must type lists out in a cons chain sort of way for now to get used to the structure of them, but in the future, there’s going to be a much easier way.</p><div class="slide"><h2 id="nested_diagram"><a class="anchor" href="#nested_diagram">#</a>Nested Diagram</h2><p><img src="images/list_nest.png" style="width: auto"/></p><figure style="width: initial;"><img src="images/dolls.gif" style="width: auto">
</img>
<figcaption><a href="https://commons.wikimedia.org/wiki/File:Matryoshka_transparent.png">User:Fanghongderivative Matryoshka Dolls CC BY-SA</a></figcaption></figure></div><div class="slide"><h2 id="box_and_pointer_diagram"><a class="anchor" href="#box_and_pointer_diagram">#</a>Box and Pointer Diagram</h2><p>Box and pointer diagrams are much more common as they take up less space and are easier to follow as the amount of items increases.<br/><img src="images/list_train.png" style="width: auto"/></p><figure style="width: initial"><img src="images/flying_scotsman_train.jpg" style="width: auto"/>
<figcaption><a href="https://commons.wikimedia.org/wiki/File:%27Flying_Scotsman%27_(40944346730).jpg" style="width: auto; text-align: center;">Peter Trimming from Croydon, England, CC BY 2.0</a></figcaption></figure></div><h2 id="list_basics_quiz"><a class="anchor" href="#list_basics_quiz">#</a>List basics quiz</h2><div class="slide"><h3>What should the following produce?</h3><p><code class="language-racket">(cons (+ 1 1) (cons 1 empty))</code></p><form><label><input name="q1" type="radio"> a.<code>3</code></input></label><br/><label><input name="q1" type="radio"> b.<code>2</code></input></label><br/><label><input name="q1" type="radio"> c.<code>(cons 3 empty)</code></input></label><br/><label><input name="q1" type="radio"> d.<code>(cons 2 (cons 1 empty))</code></input></label></form><p><details><summary>answer</summary><p> d.<code>(cons 2 (cons 1 empty))</code></p></details></p></div><div class="slide"><h3>How many elements does the following list have?</h3><p><code class="language-racket">(cons 4 empty)</code></p><form><label><input name="q1" type="radio"> a. <code>1</code></input></label><br/><label><input name="q1" type="radio"> b. <code>2</code></input></label><br/><label><input name="q1" type="radio"> c. <code>3</code></input></label><br/><label><input name="q1" type="radio"> d. <code>4</code></input></label></form><p><details><summary>answer</summary><p> a. <code>1</code></p></details></p></div><div class="slide"><h3>What is the value produced by the expression <code>(first L1)</code>?</h3><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(define L1 (cons "James" (cons "Alice" (cons "Bob" empty))))
(define L2 (cons 1 empty))</code></pre><form><label><input name="q1" type="radio"> a. <code>(cons "James Alice Bob" empty)</code></input></label><br/><label><input name="q1" type="radio"> b. <code>(cons "Alice" (cons "Bob" empty))</code></input></label><br/><label><input name="q1" type="radio"> c. <code>(cons "Bob" empty)</code></input></label><br/><label><input name="q1" type="radio"> d. <code>"James"</code></input></label><br/><label><input name="q1" type="radio"> e. <code>"Bob"</code></input></label><br/><label><input name="q1" type="radio"> f. <code>empty</code></input></label><br/><details><summary>answer</summary><p> d. <code>"James"</code></p></details></form></div><div class="slide"><h3>What is the value produced by the expression <code>(rest L1)</code>?</h3><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(define L1 (cons "James" (cons "Alice" (cons "Bob" empty))))
(define L2 (cons 1 empty))</code></pre><form><label><input name="q1" type="radio"> a. <code>(cons "James Alice Bob" empty)</code></input></label><br/><label><input name="q1" type="radio"> b. <code>(cons "Alice" (cons "Bob" empty))</code></input></label><br/><label><input name="q1" type="radio"> c. <code>(cons "Bob" empty)</code></input></label><br/><label><input name="q1" type="radio"> d. <code>"James"</code></input></label><br/><label><input name="q1" type="radio"> e. <code>"Bob"</code></input></label><br/><label><input name="q1" type="radio"> f. <code>empty</code></input></label></form><p><details><summary>answer</summary><p> b. <code>(cons "Alice" (cons "Bob" empty))</code></p></details></p></div><div class="slide"><h3>What is the value produced by the expression <code>(empty? L2)</code>?</h3><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(define L1 (cons "James" (cons "Alice" (cons "Bob" empty))))
(define L2 (cons 1 empty))</code></pre><form><label><input name="q" type="radio"> a.<code>(cons 1 empty)</code></input></label><br/><label><input name="q" type="radio"> b.<code>empty</code></input></label><br/><label><input name="q" type="radio"> c.<code>#true</code></input></label><br/><label><input name="q" type="radio"> d.<code>#false</code></input></label></form><p><details><summary>answer</summary><p> d.<code>#false</code></p></details></p></div><div class="slide"><h3>What is the value produced by the expression <code>(empty? (rest L2))</code>?</h3><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(define L1 (cons "James" (cons "Alice" (cons "Bob" empty))))
(define L2 (cons 1 empty))</code></pre><form><label><input name="q" type="radio"> a.<code>(cons 1 empty)</code></input></label><br/><label><input name="q" type="radio"> b.<code>empty</code></input></label><br/><label><input name="q" type="radio"> c.<code>#true</code></input></label><br/><label><input name="q" type="radio"> d.<code>#false</code></input></label></form><p><details><summary>answer</summary><p> c.<code>#true</code></p></details></p></div><div class="slide"><h3>What type of list is the following?</h3><p><code class="language-racket">(cons "1" (cons "2" empty))</code></p><form><label><input name="q" type="radio"> a.<code>ListOfNumber</code></input></label><br/><label><input name="q" type="radio"> b.<code>ListOfBoolean</code></input></label><br/><label><input name="q" type="radio"> c.<code>ListOfString</code></input></label></form><p><details><summary>answer</summary><p> c.<code>ListOfString</code></p></details></p></div><div class="slide"><h3>Which of the following expressions will evaluate to <code>#false</code>?</h3><form><label><input name="q" type="radio"> a.<code>(cons? (cons empty empty))</code></input></label><br/><label><input name="q" type="radio"> b.<code>(list? (cons empty empty))</code></input></label><br/><label><input name="q" type="radio"> c.<code>(empty? empty)</code></input></label><br/><label><input name="q" type="radio"> d.<code>(list? empty)</code></input></label><br/><label><input name="q" type="radio"> e.<code>(empty? (cons empty empty))</code></input></label></form><p><details><summary>answer</summary><p> e.<code>(empty? (cons empty empty))</code></p></details></p></div><div class="slide"><h3>What does the following produce?</h3><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(first (cons (cons 99 empty) (cons 45 empty)))</code></pre><form><label><input name="q" type="radio"> a.<code>99</code></input></label><br/><label><input name="q" type="radio"> b.<code>empty</code></input></label><br/><label><input name="q" type="radio"> c.<code>(cons 45 empty)</code></input></label><br/><label><input name="q" type="radio"> d.<code>(cons 99 empty)</code></input></label><br/><label><input name="q" type="radio"> e.<code>45</code></input></label></form><p><details><summary>answer</summary><p> d.<code>(cons 99 empty)</code> . You’ve seen <code>first</code> produce the base types so far, but because <code>cons</code> takes as its 1st argument <strong>anything</strong>, we can stick a list there as well.</p></details></p></div><div class="slide"><h3>How do you get the 99 out of the following expression?</h3><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(define x (cons (cons 99 empty) (cons 45 empty)))</code></pre><form><label><input name="q" type="radio"> a.<code>(rest x)</code></input></label><br/><label><input name="q" type="radio"> b.<code>(first x)</code></input></label><br/><label><input name="q" type="radio"> c.<code>(rest (first x))</code></input></label><br/><label><input name="q" type="radio"> d.<code>(first (first x))</code></input></label><br/><label><input name="q" type="radio"> e.<code>(rest (rest x))</code></input></label></form><p><details><summary>answer</summary><p> d.<code>(first (first x))</code><br/>because:<br/><code>(first x) -&gt; (cons 99 empty)</code><br/>And then we have to take the first of that again to get the 99 out:<br/><code>(first (cons 99 empty)) -&gt; 99</code></p></details></p></div><div class="slide"><h3>How many elements are in this list?</h3><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(cons (cons 4 empty) (cons 3 empty))</code></pre><form><label><input name="q" type="radio"> a.1</input></label><br/><label><input name="q" type="radio"> b.2</input></label><br/><label><input name="q" type="radio"> c.3</input></label><br/><label><input name="q" type="radio"> d.4</input></label><br/><label><input name="q" type="radio"> e.5</input></label></form><p><details><summary>answer</summary><p> b.<code>2</code></p></details></p></div><div class="slide"><h3>Which ones of the following are INVALID ways to construct a list? Check all that apply</h3><form><label><input name="q" type="checkbox"> a.<code>(cons 5 empty)</code></input></label><br/><label><input name="q" type="checkbox"> b.<code>(cons #false #false)</code></input></label><br/><label><input name="q" type="checkbox"> c.<code>(cons "argh" (cons "moo" empty))</code></input></label><br/><label><input name="q" type="checkbox"> d.<code>(cons (cons 21 empty))</code></input></label><br/><label><input name="q" type="checkbox"> e.<code>(cons 999)</code></input></label></form><p><details><summary>answer</summary><p> b, d, and e</p></details></p></div><div class="slide"><h3>Write a function swap that consumes a two-element list and produces a new two-element list containing the elements of the original list in the opposite order. For example, given:</h3><p><code>(cons 3 (cons 2 empty))</code>,<br/>produce:<br/><code>(cons 2 (cons 3 empty))</code>.</p><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; swap: (ListOfAny -&gt; ListOfAny)
; consumes a two element list and swaps their order
(check-expect
    (swap (cons 3 (cons 2 empty)))
          (cons 2 (cons 3 empty)))

(check-expect
    (swap (cons 0 (cons 5 empty)))
          (cons 5 (cons 0 empty)))

; (define (swap ls) empty)

(define (swap ls)
    (... ls))</code></pre><p><details><summary>answer</summary><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(define (swap ls)
    (cons (first (rest ls))
        (cons (first ls) empty)))</code></pre></details></p></div><p>Lists are where things start ramping up in difficulty as you’ll see shortly, so it’s very important you have an intuitive grasp of these basic list operations!</p><h3>Extra: Internals</h3><p>This is an extra section if you want to know the “internals” of lists.<br/>There is a clever trick that we can define structures such that we can chain values together. What we do is that in our data definition, we do a self reference. The <code>empty</code> is just a distinct type, <code>empty-link</code></p><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; Link is one of:
; (make-empty-Link)
; (make-Link Any Link)

(define-struct empty-link []) ; has no fields
(define-struct link [first rest])

(make-empty-link) ; equiv to: empty or '()
(make-link 0 (make-empty-link)) ; 1 element list

(make-link 0 (make-link 2 (make-empty-link))) ; 2 element list

; 3 element list:
(make-link 1
           (make-link 2
                      (make-link 3
                                 (make-empty-link))))</code></pre>
            </article>
        </main>
    </div>
</body>

</html>