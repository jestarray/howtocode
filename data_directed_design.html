<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://unpkg.com/sanitize.css" rel="stylesheet" />
    <link rel="stylesheet" type="text/css" media="all" href="/styles.css" />
    <script src="/prism_highlight.js"></script>
    <link rel="stylesheet" type="text/css" media="all" href="/prism.css" />
    <script src="./slide_mode.js"></script>
    <!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "268f8e8ed1cf4189996214dfee7b9d3e"}'></script><!-- End Cloudflare Web Analytics -->
    <link rel="shortcut icon" type="image/jpg" href="images/htc_favicon.png"/>
    <title>Data Directed Design</title>
</head>

<body>
    <div class="container">
        <main class="main-wrapper">
            <div id="prev">← <a href="/lists.html"> Lists</a></div>
            <div id="home"><a href="/index.html">Index</a></div>

            <article>
                <h1>Data Directed Design</h1><p>The structure of the code should mirror the structure of the data definitions. Here we can see this done in some of the data definitions we’ve done before:</p><div class="slide"><h2 id="enum_data"><a class="anchor" href="#enum_data">#</a>Enum data</h2><p><img src="images/dd_enum_arrows.png"/></p></div><div class="slide"><h2 id="union_data"><a class="anchor" href="#union_data">#</a>Union data</h2><p><img src="images/dd_union_arrows.png"/></p></div><div class="slide"><h2 id="self_referential_data(recursion)"><a class="anchor" href="#self_referential_data(recursion)">#</a>Self Referential Data(Recursion)</h2><p><img src="images/dd_selfref_arrows.png"/></p></div><div class="slide"><h2 id="the_two_main_things_you_need_to_focus_on_are:"><a class="anchor" href="#the_two_main_things_you_need_to_focus_on_are:">#</a>The two main things you need to focus on are:</h2><p>    </p><ol><li><h3>Base case: what we do when the list is empty, aka the termination condition</h3></li><li><h3>How to contribute/combine to the base case</h3><p> Focus on the 1 list long case and how you combine it with the base case to achieve the intended purpose, and trust that it will just work for a list of any length</p></li></ol><h2 id="self_reference_template"><a class="anchor" href="#self_reference_template">#</a>Self reference template</h2><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; ListOfNumbers is one of:
; - empty
; - (cons Number ListOfNumber)
; interp. a list of numbers

; examples:
(define nothing empty)
(define one-ls (cons 99 empty))
(define two-ls (cons 4 (cons 6 empty)))
(define three-ls (cons 1 (cons 8 (cons 5 empty))))

(define (list-of-nums-temp lst)
  (cond [(empty? lst) ...] ; ◄────── (1) ... base case
        [else
         (... (first lst)
              (list-temp (rest lst)))]))
        ; ▲
        ; │
        ; │
        ; (2) ... contribution to the base</code></pre><p>    Notice how the Data Definition maps to the code. It’s a <code>one of</code>, so we need a <code>cond</code> with two matching cases. In the 2nd case, we use <code>else</code> for short. <strong>Always use the derived template as starter code, as all recursive functions will have this structure.</strong></p></div><div class="slide"><h2 id="recursion_exercise"><a class="anchor" href="#recursion_exercise">#</a>Recursion Exercise</h2><p>Use the design recipe and <strong>recursive template</strong> to work through the following 3 problems<br/><code>sum-price , count-items , has-peanuts?</code></p><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; ListOfNumber is one of:
; - empty
;- (cons Number ListOfNumber)
; interp. a sequence of numbers
; TODO: TEMPLATE

; sum-prices : (ListOfNumber -&gt; Number)
; produces the sum total of the numbers in the given list

; count-items: (ListOfNumber -&gt; Number)
; produces the amount of numbers in the given list

; ListOfString is one of:
; - empty
;- (cons String ListOfString)
; interp. a sequnce of strings
; TODO: TEMPLATE

; has-peanuts? : (ListOfString -&gt; Boolean)
; produces #true if the list contains "peanuts"</code></pre><p><details><summary>answer</summary><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; Notice the similarities between 3 recursive functions

; ListOfNumber is one of:
; - empty
;- (cons Number ListOfNumber)
; interp. a sequence of numbers
(define (list-num-temp num-ls)
  (cond
    [(empty? num-ls) ...]
    [else
     (... (first num-ls)
          (list-num-temp (rest num-ls)))]))

; sum-prices : (ListOfNumber -&gt; Number)
; produces the sum total of the numbers in the given list
(check-expect (sum-prices empty) 0)
(check-expect (sum-prices (cons 0.50 (cons 4 empty))) (+ 4 0.50))
(check-expect (sum-prices (cons 2 (cons 1 (cons 7 empty)))) (+ 2 1 7))
(define (sum-prices num-lst)
  (cond
    [(empty? num-lst) 0]
    [else
     (+  (first num-lst)
         (sum-prices (rest num-lst)))]))

; count-items: (ListOfNumber -&gt; Number)
; produces the amount of numbers in the given list
(check-expect (count-items empty) 0)
(check-expect (count-items (cons 33 (cons 4 empty))) 2)
(define (count-items num-lst)
  (cond
    [(empty? num-lst) 0]
    [else
     (+ 1
        (count-items (rest num-lst)))]))

; ListOfString is one of:
; - empty
;- (cons String ListOfString)
; interp. a sequnce of strings
(define (list-string-temp str-ls)
  (cond
    [(empty? str-ls) ...]
    [else
     (... (first str-ls)
          (list-string-temp (rest str-ls)))]))

; has-peanuts? : (ListOfString -&gt; Boolean)
; produces #true if the list contains "peanuts"
(check-expect (has-peanuts? empty) #false)
(check-expect (has-peanuts? (cons "vanilla" (cons "chocolate" empty))) #true)
(check-expect (has-peanuts? (cons "mint" (cons "peanuts" empty))) #true)
(define (has-peanuts? str-lst)
  (cond
    [(empty? str-lst) #false]
    [else
     (if (string=? (first str-lst) "peanuts")
         #true
         (has-peanuts? (rest str-lst)))]))</code></pre></details></p></div><div class="slide"><h2 id="similarities"><a class="anchor" href="#similarities">#</a>Similarities</h2><p>Here’s a table in the main ways they are similar but differ:</p><table><caption></caption><thead><th>Function</th>
<th>Base</th>
<th>Contribution of first</th>
<th>Combination</th></thead>
<tbody><tr><td><code>has-peanuts?</code></td>
<td><code>false</code></td>
<td><code>(string=? (first str-lst) "peanuts")</code></td>
<td><code>(if &lt;condition&gt; #true &lt;recurse&gt;)</code></td></tr>
<tr><td><code>sum-prices</code></td>
<td><code>0</code></td>
<td><code>(first nums)</code> the price itself</td>
<td><code>+</code></td></tr>
<tr><td><code>count-items</code></td>
<td><code>0</code></td>
<td>1</td>
<td><code>+</code></td></tr></tbody></table></div><p>Look in the <a href="https://docs.racket-lang.org/htdp-langs/beginner.html">BSL documentation</a> for the combinator. If it doesn’t exist, wishlist it!</p><p>I’m sure you’re feeling:<br/><strong>Wait a minute</strong>, when I write the recrusive call, I’m <strong>assuming</strong> this functions fullfills its purpose statement and just works? But I haven’t even finished writing the function yet, in fact I’m still in the middle of writing it! It’s weird... It feels like magic, like cheating! Not to mention purpose statements are just comments!</p><div class="slide"><h2 id="how_does_it_work?"><a class="anchor" href="#how_does_it_work?">#</a>How does it work?</h2><p>The individual/micro/mechanical operations of recursive functions expliots the rule that we’ve learned all the way in the start of the course, and that is that <strong>function operands</strong>(aka parameters, inputs, arguments) <strong>need to be values</strong> before the <strong>operator</strong> can do its job. Let’s explore this in a bit more detail!</p><p>Use the stepper and step through this expression:</p><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(+ (* 2 6  (/ 4 4)) (- 1 1))</code></pre><p>This is the order of <strong>calls</strong>:<br/>Calling:<br/><code>+</code> is <strong>called 1st</strong><br/><code>*</code> is <strong>called 2nd</strong><br/><code>/</code> is <strong>called 3rd</strong><br/><code>-</code> is <strong>called last</strong></p><p>Even though <strong>+</strong> is called first, it has to wait until all of its operands resolve into values, so it is executed last. The order of the operations that <strong>executes</strong> is different:</p><p>Executing:<br/><code>/</code> is <strong>executed 1st</strong><br/><code>*</code> is <strong>executed 2nd</strong><br/><code>-</code> is <strong>executed 3rd</strong><br/><code>+</code> is <strong>executed last</strong></p></div><div class="slide">Note that <em>calling and executing are two different things</em>.<br/><strong>Calling</strong> a function is like putting it on a todolist.<br/><strong>Executing</strong> a function is doing the operation.</div><p>As a function calls itself, it will build a sort of “chain” of calls until it hits and stops at the base case. Let’s see this in action using the stepper to step through the call to:<br/><code>(sum-prices (cons 2 (cons 1 (cons 7 empty))))</code></p><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket"> (+
  2
  (+
   1
   (+
    7
    (cond
     [(empty? '()) 0] ; &lt;- the base case
     [else
      (+ (first '()) (sum-prices (rest '())))]))))

; hitting the base case:
 (+
  2
  (+
   1
   (+
    7
    (cond
     [#true 0] ; &lt;- the base case
     [else
      (+ (first '()) (sum-prices (rest '())))]))))

; the "final" expression, a chain of calls:
 (+
  2
  (+
   1
   (+
    7
     0))) ; &lt;- the base case
; ^ re-written more neatly without the spacing:
(+ 2 (+ 1 (+ 7 0)))</code></pre><div class="slide"><h2 id="table_method"><a class="anchor" href="#table_method">#</a>Table method</h2><p>It is often better to write out the execution in a <a href="https://samagino.github.io/Beginning-Student-Tables/">table format</a> for more of a birds eye view. Here is the execution of <code>sum-prices</code> when it is given the list <code>(cons 2 (cons 1 (cons 7 empty)))</code>:</p><table><caption></caption><thead><th>step#</th>
<th>lst</th>
<th>(empty? lst)</th>
<th>(first lst)</th>
<th>(rest lst)</th></thead>
<tbody><tr><td>1</td>
<td><code>(cons 2 (cons 1 (cons 7 empty)))</code></td>
<td><code>false</code></td>
<td><code>2</code></td>
<td><code>(cons 1 (cons 7 empty))</code></td></tr>
<tr><td>2</td>
<td><code>(cons 1 (cons 7 empty))</code></td>
<td><code>false</code></td>
<td><code>1</code></td>
<td><code>(cons 7 empty)</code></td></tr>
<tr><td>3</td>
<td><code>(cons 7 empty)</code></td>
<td><code>false</code></td>
<td><code>7</code></td>
<td><code>empty</code></td></tr>
<tr><td>4</td>
<td><code>empty</code> <mark>base case: <code>0</code></mark></td>
<td><code>true</code></td>
<td>ERROR</td>
<td>ERROR</td></tr></tbody>
<caption><code>(+ 2 (+ 1 (+ 7 0)))</code>
<p>Note that the base case produces: <code>0</code></p></caption></table></div><div class="slide"><h2 id="top_mistakes_students_make_when_doing_recursion"><a class="anchor" href="#top_mistakes_students_make_when_doing_recursion">#</a>Top mistakes students make when doing recursion</h2><ol><li><a href="https://youtu.be/Ae7g73jM4J4?feature=shared&amp;t=733">Being overly concerned/hung up on the individual micro/mechanical operations of recursive functions</a></li><li>Not writing or using a template as a starter</li><li>Not using the stepper/writing things down in a table</li><li>Not having a <strong>clear</strong> purpose statement and trusting it, and focusing too much on the code. Purpose statements should focus on <strong>what</strong> the function computes not <strong>how</strong> it goes about it</li><li>Forgetting to write the natural recursion on the rest of the list in the function(step through <code>has-peanuts?</code> without the natural recusive call)</li><li>Not having a good base case</li><li>Not having the functions follow the signature</li></ol></div><div class="slide"><h2 id="debugging_recursive_functions"><a class="anchor" href="#debugging_recursive_functions">#</a>Debugging recursive functions</h2><ol><li>Comment out all tests <strong>except the failing one</strong>, and use the stepper</li><li>Write out in a table the first and rest of every call to get a birds eyeview: <a href="https://samagino.github.io/Beginning-Student-Tables/">beginning student tables</a></li></ol></div><div class="slide"><h2 id="why_is_recursion_hard?"><a class="anchor" href="#why_is_recursion_hard?">#</a>Why is recursion hard?</h2><h3>1. Default mindset: Humans think sequentially (“do A, then B, then C”).</h3><p>Recursion demands: “Solve a smaller version of the problem first, then combine results”—a backwards or self-referential logic.</p><p>Example:</p><p>Iterative: “To climb 10 stairs, step 1, then 2, then 3...”</p><p>Recursive: “To climb 10 stairs, first know how to climb 9 stairs, then add one more step.”</p><p>Why it feels unnatural: Recursion asks us to delegate the work before seeing the result, which feels like “cheating”, compared to the iteration where we can see all the previous steps before us more easily.</p><h3>2. The Fear of the Unknown</h3><p>Desire for control: People want to trace every call to feel “sure” it works.</p><p>Recursion’s opacity: Each recursive call hides complexity, creating unease.</p><h3>3. Infinite Loop Anxiety</h3><p>Base-case paranoia: Missing or incorrect base cases lead to infinite recursion (and stack overflows). In contrast to iteration, we have a more intuitive grasp at when we end up front with very little chances of infinite looping.</p><p>The idea of why recursion works is similar to proofs by <a href="https://youtu.be/x5cWX-EyLEI">mathematical induction</a>.</p></div>
            </article>
        </main>
    </div>
</body>

</html>