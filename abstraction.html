<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://unpkg.com/sanitize.css" rel="stylesheet" />
    <link rel="stylesheet" type="text/css" media="all" href="/styles.css" />
    <script src="/prism_highlight.js"></script>
    <link rel="stylesheet" type="text/css" media="all" href="/prism.css" />
    <script src="./slide_mode.js"></script>
    <!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "268f8e8ed1cf4189996214dfee7b9d3e"}'></script><!-- End Cloudflare Web Analytics -->
    <link rel="shortcut icon" type="image/jpg" href="images/htc_favicon.png"/>
    <title>Abstraction</title>
</head>

<body>
    <div class="container">
        <main class="main-wrapper">
            <div id="prev">← <a href="/list_abbvr.html"> List Abbreviation</a></div>
            <div id="home"><a href="/index.html">Index</a></div>

            <article>
                <h1>Abstraction</h1><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; Instead of calculating area of a circle for 5 and 10
(* pi 5 5)
(* pi 10 10)

; We can "abstract"(make more general) it with a function
; that factors out the difference
(: circle-area (Number -&gt; Number))
; produces the area of a r radius circle
(define (circle-area r)
  (* pi r r))
(circle-area 5)
(circle-area 10)</code></pre><h2 id="similarities"><a class="anchor" href="#similarities">#</a>Similarities</h2><p><img src="images/similar_c.gif"/></p><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(: contains-dog? ([ListOf String] -&gt; Boolean))
; produces #true if the list contains "dog"
(check-expect (contains-dog? (list "cow" "dog")) #true)
(define (contains-dog? lst)
  (cond
    [(empty? lst) #false]
    [else
     (or (string=? (first lst) "dog")
         (contains-dog? (rest lst)))]))

(: contains-cat? ([ListOf String] -&gt; Boolean))
; produces #true if the list contains "cat"
(check-expect (contains-cat? (list "sheep" "cat")) #true)
(define (contains-cat? lst)
  (cond
    [(empty? lst) #false]
    [else
     (or (string=? (first lst) "cat")
         (contains-cat? (rest lst)))]))</code></pre><p>Notice how the two functions above, <code>contains-dog?</code> and <code>contains-cat?</code> are 90% similar! The main difference is in:<br/><code>(string=? (first lst) "cat")</code><br/><code>(string=? (first lst) "dog")</code></p><h2 id="abstract_via_parameters"><a class="anchor" href="#abstract_via_parameters">#</a>Abstract via Parameters</h2><p>We fan factor out the string <code>"cat"</code> and <code>"dog"</code> into a parameter and implement <code>contains-dog?</code> and <code>contains-cat?</code> using a more general <strong>abstract</strong> <code>contains?</code> function.</p><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(: contains-dog? ([ListOf String] -&gt; Boolean))
; produces #true if the list contains "dog"
(check-expect (contains-dog? (list "cow" "dog")) #true)
(define (contains-dog? lst)
  (contains? lst "dog"))

(: contains-cat? ([ListOf String] -&gt; Boolean))
; produces #true if the list contains "cat"
(check-expect (contains-dog? (list "sheep" "cat")) #true)
(define (contains-cat? lst)
  (contains? lst "cat"))

(: contains? ([ListOf String] String -&gt; Boolean))
; produces #true if the given string is in the list
(define (contains? lst find-str)
  (cond
    [(empty? lst) #false]
    [else
     (or (string=? (first lst) find-str)
         (contains? (rest lst)))]))</code></pre><p>This reduces bugs as we only need to look at <code>contains?</code> which holds the main logic and provides a more general useful function that’s able to look for any string in a list instead of just <code>"cat"</code> and <code>"dog"</code></p><p><details><summary class="question">Exercise 1</summary><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(: add1* ([ListOf Number] -&gt; [ListOf Number]))
; adds 1 to each item on lst
(check-expect (add1* (list 1 3 5)) (list 2 4 6))
(define (add1* lst)
  (cond
    [(empty? lst) empty]
    [else
     (cons
      (add1 (first lst))
      (add1* (rest lst)))]))

(: plus5 ([ListOf Number] -&gt; [ListOf Number]))
(check-expect (plus5 (list 1 3 5)) (list 6 8 10))
; adds 5 to each item on lst
(define (plus5 lst)
  (cond
    [(empty? lst) empty]
    [else
     (cons
      (+ (first lst) 5)
      (plus5 (rest lst)))]))

; PROBLEM A: ABSTRACT add1* &amp; plus5 into a new general abstract function
; TODO

; PROBLEM B: Reimplement the add1* &amp; plus5 with the abstract function from PROBLEM A
; TODO</code></pre><p><details><summary class="question">Answer</summary><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(: add1* ([ListOf Number] -&gt; [ListOf Number]))
; adds 1 to each item on lst
(check-expect (add1* (list 1 3 5)) (list 2 4 6))
(define (add1* lst)
  (add-n lst 1))

(: plus5 ([ListOf Number] -&gt; [ListOf Number]))
(check-expect (plus5 (list 1 3 5)) (list 6 8 10))
; adds 5 to each item on lst
(define (plus5 lst)
  (add-n lst 5))

; PROBLEM A: ABSTRACT add1* &amp; plus5 into a new general abstract function
(: add-n ([ListOf Number] Number -&gt; [ListOf Number]))
; adds-n to every number in lst
(define (add-n lst n)
  (cond
    [(empty? lst) empty]
    [else
     (cons
      (+ n (first lst))
      (add-n (rest lst) n))]))

; PROBLEM B: Reimplement the add1* &amp; plus5 with the abstract function from PROBLEM A
; (done, see above)</code></pre></details></p></details></p><h2 id="recipe_for_abstraction"><a class="anchor" href="#recipe_for_abstraction">#</a>Recipe for Abstraction</h2><ol><li>Compare two items for similarities in text and behavior</li><li>Abstract! Replace the common inessential differences with new names and add these names to the parameter list.</li><li>Rewrite your old function in terms of the new abstraction function, and validate tests</li><li>Rewrite the signature for the new abstraction(hardest)</li></ol><p>When you abstract, you tend to write the signature last because it will be the hardest part, due to the signatures also needing to be more abstract(aka generic).</p><h2 id="abstract_via_function_parameters"><a class="anchor" href="#abstract_via_function_parameters">#</a>Abstract via Function Parameters</h2><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; PROBLEM A: Write tests for "smaller-than" and "larger-than"
(: smaller-than ([ListOf Number] Number -&gt; [ListOf Number]))
; keep only those numbers smaller than the given "limit"
; TODO TESTS
(define (smaller-than lst limit)
  (cond
    [(empty? lst) empty]
    [else
     (if (&lt; (first lst) limit)
         (cons (first lst) (smaller-than (rest lst) limit))
         (smaller-than (rest lst) limit))]))

(: larger-than ([ListOf Number] Number -&gt; [ListOf Number]))
; keep only those numbers biggers than the given "limit"
; TODO TESTS
(define (larger-than lst limit)
  (cond
    [(empty? lst) empty]
    [else
     (if (&gt; (first lst) limit)
         (cons (first lst) (larger-than (rest lst) limit))
         (larger-than (rest lst) limit))]))

; PROBLEM B: Abstract "smaller-than" &amp; "larger-than" with a NEW function, call it "extract"
; TODO

; PROBLEM C: Use the abstracted function from PROBLEM B to re-implement "smaller-than" &amp; "larger-than"
; TODO</code></pre><p><details><summary class="question">Answer</summary><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; PROBLEM A: Write tests for "smaller-than" and "larger-than"
(: smaller-than ([ListOf Number] Number -&gt; [ListOf Number]))
; keep only those numbers smaller than the given "limit"
(check-expect (smaller-than (list 1 2 3 4) 3)
              (list 1 2))
(define (smaller-than lst limit)
  (cond
    [(empty? lst) empty]
    [else
     (if (&lt; (first lst) limit)
         (cons (first lst) (smaller-than (rest lst) limit))
         (smaller-than (rest lst) limit))]))

(: larger-than ([ListOf Number] Number -&gt; [ListOf Number]))
; keep only those numbers biggers than the given "limit"
(check-expect (larger-than (list 1 2 3 4) 2)
              (list 3 4))
(define (larger-than lst limit)
  (cond
    [(empty? lst) empty]
    [else
     (if (&gt; (first lst) limit)
         (cons (first lst) (larger-than (rest lst) limit))
         (larger-than (rest lst) limit))]))

; PROBLEM B: Abstract "smaller-than" &amp; "larger-than" with a NEW function, call it "extract"
(: extract ((Number Number -&gt; Boolean) [ListOf Number] Number -&gt; [ListOf Number]))
; extract numbers based on the given "fn" and limit
(define (extract fn lst limit)
  (cond
    [(empty? lst) empty]
    [else
     (if (fn (first lst) limit)
         (cons (first lst) (extract fn (rest lst) limit))
         (extract fn (rest lst) limit))]))

; PROBLEM C: Use the abstracted function from PROBLEM B to re-implement "smaller-than" &amp; "larger-than"
(: smaller-thanv2 ([ListOf Number] Number -&gt; [ListOf Number]))
; keep only those numbers smaller than the given "limit"
(check-expect (smaller-thanv2 (list 1 2 3 4) 3)
              (list 1 2))
(define (smaller-thanv2 lst limit)
  (extract &lt; lst limit))

(: larger-thanv2 ([ListOf Number] Number -&gt; [ListOf Number]))
; keep only those numbers biggers than the given "limit"
(check-expect (larger-thanv2 (list 1 2 3 4) 2)
              (list 3 4))
(define (larger-thanv2 lst limit)
  (extract &gt; lst limit))</code></pre></details></p><p>Yes! You can even pass in function just like you would any old data like booleans, strings, numbers, and this gives us a very powerful tool to abstract things!</p><h2 id="abstracting_signatures"><a class="anchor" href="#abstracting_signatures">#</a>Abstracting Signatures</h2><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">#lang htdp/isl+
; ========== data defs ==========

; ListOfString is one of:
; - empty
; - (cons String ListOfString)

; ListOfNumber is one of:
; - empty
; - (cons Number ListOfNumber)

; INSTEAD, we can have data definitions over some X, like functions:

; [ListOf X] is one of:
; - empty
; - (cons X [ListOf X])

; =============================
; Abstracting function sigs:

; ========== keep-if ==========

;(: keep-if ((Number -&gt; Boolean) [ListOf Number] -&gt; [ListOf Number]))
; keep only the given items if they pass the given criteria
(define (keep-if fn lst)
  (cond
    [(empty? lst) empty]
    [else
     (if (fn (first lst))
         (cons (first lst) (keep-if fn (rest lst)))
         (keep-if fn (rest lst)))]))

(: positives-only ([ListOf Number] -&gt; [ListOf Number]))
; keep only the positive numbers in the given list
(check-expect (positives-only (list -1 0 -4 9)) (list 9))
(define (positives-only lst)
  (keep-if positive? lst))

(: no-yelling ([ListOf String] -&gt; [ListOf String]))
; produces a list that removes any strings with capital letters
(check-expect (no-yelling (list "yay" "noO" "meow")) (list "yay" "meow"))
(define (no-yelling lst)
  (keep-if string-lower-case? lst))


; ========== do-to-all ==========

; (: do-to-all ((Number -&gt; Number) [ListOf Number] -&gt; [ListOf Number]))
; given (list n0 n1 ...) produce the function applied to each element (list (fn n0) (fn n1) ...)
(define (do-to-all fn lst)
  (cond
    [(empty? lst) empty]
    [else
     (cons
      (fn (first lst))
      (do-to-all fn (rest lst)))]))

(: square-all ([ListOf Number] -&gt; [ListOf Number]))
; produce a list with all the given numbers squared
(check-expect (square-all (list 1 2 3)) (list 1 4 9))
(define (square-all lst)
  (do-to-all sqr lst))

(: word-len-all ([ListOf String] -&gt; [ListOf Number]))
; produce the string-length of every string in the list
(check-expect (word-len-all (list "moo" "woof" "meow")) (list 3 4 4))
(define (word-len-all lst)
  (do-to-all string-length lst))


; ========== collapse ==========
; (: collapse ((Number -&gt; Number) Number [ListOf Number] -&gt; Number))
(define (collapse fn base lst)
  (cond
    [(empty? lst) base]
    [else
     (fn (first lst) (collapse fn base (rest lst) ))]))

(: sum-nums ([ListOf Number] -&gt; Number))
; sum up all the numbers in the given list
(check-expect (sum-nums empty) 0)
(check-expect (sum-nums (list 2 4)) 6)
(define (sum-nums lst)
  (collapse + 0 lst))

(: word-count ([ListOf String] -&gt; Number))
; produces the total number of letters in the list
(check-expect (word-count (list "cow" "meow")) 7)
(define (word-count lst)
  ; (String Number -&gt; Number) Number [ListOf String]
  (collapse add-wlen 0 lst))

(: add-wlen (String Number -&gt; Number))
(define (add-wlen str base)
  (+ (string-length str) base))</code></pre>
            </article>
        </main>
    </div>
</body>

</html>