<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://unpkg.com/sanitize.css" rel="stylesheet" />
    <link rel="stylesheet" type="text/css" media="all" href="/styles.css" />
    <script src="/prism_highlight.js"></script>
    <link rel="stylesheet" type="text/css" media="all" href="/prism.css" />
    <script src="./slide_mode.js"></script>
    <!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "268f8e8ed1cf4189996214dfee7b9d3e"}'></script><!-- End Cloudflare Web Analytics -->
    <link rel="shortcut icon" type="image/jpg" href="images/htc_favicon.png"/>
    <title>Templates and Outlines</title>
</head>

<body>
    <div class="container">
        <main class="main-wrapper">
            <div id="prev">← <a href="/cheatsheet.html"> Syntax Cheat Sheet</a></div>
            <div id="home"><a href="/index.html">Index</a></div>
            <div id="next"><a href="/introduction.html">Introduction</a> →</div>
            <article>
                <h1>Templates and Outlines</h1><p>Templates, or as I’d like to call them, “outlines”, is the bare minimum baseline to kickstart writing a function. It’s akin to laying out all your tools neatly before picking which one to use, or like an artist drawing a rough outline/sketch as a baseline. If you’ve tried visual block based languages like <a href="https://scratch.mit.edu/">Scratch</a>, it lays out all the blocks for you that you can use, and this is what tempaltes accomplish, to gather all the available puzzle pieces(e.g parameters and basic structure) we can use, as the alternative is staring at a blank page stunned. As you program more and more, you’ll be able to template problems in your head.</p><h2 id="simple_base_data(concrete)"><a class="anchor" href="#simple_base_data(concrete)">#</a>Simple Base Data(concrete)</h2><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(define (&lt;FUN-BASE-TEMPLATE&gt; arg1)
  (... arg1))

; double: (Number -&gt; Number)
; produces double the given number

(check-expect (double 2) 4)
(check-expect (double 3.5) 10)
; stub (define (double n) 0)

(define (double n)
  (... n))
</code></pre><h2 id="enum"><a class="anchor" href="#enum">#</a>Enum</h2><p>Enums list all finite possibilities of a given catatgorey of data you want to represent</p><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; A TrafficLight is one of the following Strings:
; – "red"
; – "green"
; – "yellow"
; interpretation the three strings represent the three 
; possible states that a traffic light may assume

; TEMPLATE should match amount of cases in the type above, in this case 3 branches:
(define (&lt;FUN-ENUM-TEMPLATE&gt; st)
  (cond
    [string=? st ...]
    [string=? st ...]
    [string=? st ...]))

; traffic-light-next: (TrafficLight -&gt; TrafficLight)
; yields the next state given current state st
(check-expect (traffic-light-next "red") "green")

(define (traffic-light-next st)
  (cond
    [(string=? "red" st) ...]
    [(string=? "green" st) ...]
    [(string=? "yellow" st) ...]))
</code></pre><h2 id="intervals"><a class="anchor" href="#intervals">#</a>Intervals</h2><p>Use an interval when the information to be represented is numbers within a certain range. Integer[0, 10] is all the integers from 0 to 10 inclusive; Number[0, 10) is all the numbers</p><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; Countdown is Integer[0, 10]
; interp. the number of seconds remaining to liftoff

(define C1 10)  ; start
(define C2 5)   ; middle
(define C3 0)   ; end

; fn-for-countdown: (Number -&gt; ???)

(define (fn-for-countdown cd)
  (... cd))
</code></pre><h2 id="interval_cheatsheet"><a class="anchor" href="#interval_cheatsheet">#</a>Interval cheatsheet</h2><p>The boolean expression to test whether a number falls <strong>within</strong> a given interval:</p><table><caption></caption><thead><th>Interval</th>
<th>Expression</th>
<th>Meaning</th></thead>
<tbody><tr><td>[0, 100]</td>
<td><code>(and (&gt;= n 0) (&lt;= n 100))</code></td>
<td><strong>Include</strong> both 0 and 100</td></tr>
<tr><td>[0, 100)</td>
<td><code>(and (&gt;= n 0) (&lt; n 100))</code></td>
<td>Include 0 but <strong>exclude</strong> 100</td></tr>
<tr><td>(0, 100]</td>
<td><code>(and (&gt; n 0) (&lt;= n 100))</code></td>
<td><strong>Exclude</strong> 0 but <strong>Include</strong> 100</td></tr>
<tr><td>(0, 100)</td>
<td><code>(and (&gt; n 0) (&lt; n 100))</code></td>
<td><strong>Exclude</strong> both 0 and 100</td></tr></tbody>
<caption>Notice you will see an <code>=</code> (equal sign) where there are <code>[]</code> (square braces)</caption></table><h2 id="sets_of_intervals"><a class="anchor" href="#sets_of_intervals">#</a>Sets of Intervals</h2><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; NumberGrade is one of:
; (80, 100]
; (60, 80]
; (40, 60]
; (20, 40]
; [0, 20]
; interp.
; (80, 100] = A
; (60, 80] =  B
; (40, 60] =  C
; (20, 40] =  D
; [0, 20] = F

(define e1 80)

; numgrade-temp: (NumberGrade -&gt; ???)
(define (numgrade-temp num)
  (cond
    [(and (&gt; num 80) (&lt;= num 100)) ...]
    [(and (&gt; num 60) (&lt;= num 80)) ...]
    [(and (&gt; num 40) (&lt;= num 60)) ...]
    [(and (&gt; num 20) (&lt;= num 40)) ...]
    [(and (&gt;= num 0) (&lt;= num 20)) ...]))
</code></pre><h2 id="union"><a class="anchor" href="#union">#</a>Union</h2><p>Union(aka itemization) describes the case when there are two or more different <strong>types</strong> of data.</p><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; ValidID is one of:
; #false
; Number
; interp. #false means there is no ID while Number is the ID

; TEMPLATE should match the number of cases above and check with typeof: "&lt;type&gt;?" 
(define (&lt;id-fun&gt; x)
  (cond [(boolean? x) ...]
        [(number? x) ...]))

; pull-over-id-check?: (ValidId -&gt; Boolean)
; returns true if the person has a valid id, otherwise false
(define (pull-over-id-check? x)
  (cond [(boolean? x) #false]
        [(number? x) #true]))
</code></pre><h2 id="compound_data_aka_structs"><a class="anchor" href="#compound_data_aka_structs">#</a>Compound Data aka Structs</h2><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">(define-struct person (name age))
; Person is (make-ball String Number)
; interp. a person comrpises of a name and age

(define P1 (make-person "bob" 10))

; (: person-name ((PersonOf String Number) -&gt; String))
; (: person-age ((PersonOf String Number) -&gt; Number))
; (: person? (Any-&gt; Boolean))

; TEMPLATE should list all the field accessors
(define (fn-for-person p)
  (... (person-name p)
       (person-age p)))
</code></pre><h2 id="recursive_functions"><a class="anchor" href="#recursive_functions">#</a>Recursive Functions</h2><pre class="line-numbers match-braces rainbow-braces"><code class="language-racket">; ListOfString is one of:
;  - empty
;  - (cons String ListOfString)
; interp. a list of strings

(define LOS-1 empty)
(define LOS-2 (cons "a" empty))
(define LOS-3 (cons "b" (cons "c" empty)))

#;
(define (fn-for-los los)
  (cond [(empty? los) (...)]                   ;BASE CASE
        [else (... (first los)                 ;String
                   (fn-for-los (rest los)))])) ;NATURAL RECURSION
;             /
;            /
;       COMBINATION
</code></pre><h2 id="data_driven_templates"><a class="anchor" href="#data_driven_templates">#</a>Data Driven Templates</h2><table><caption></caption><thead><th>Type of Data</th>
<th>cond question (if applicable)</th>
<th>Body or cond answer(if applicable)</th></thead>
<tbody><tr><td><strong>Base Generic</strong>
  <ul><li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Image</li></ul></td>
<td>Appropriate Predicate
<ul><li><code>(number? x)</code></li>
<li><code>(string? x)</code></li>
<li><code>(boolean? x)</code></li>
<li><code>(image? x)</code></li>
<li><code>(and (&lt;= 0 x) (&lt; x 10))</code></li></ul></td>
<td>Expression that operates on the parameter.
(... x)</td></tr>
<tr><td><strong>Base Concrete</strong>
  <ul><li><code>"red"</code></li>
<li><code>#f</code></li>
<li><code>empty</code></li>
<li><code>5</code></li>
<li><code>etc</code></li></ul></td>
<td>Appropriate Predicate
<ul><li><code>(string=? x "red")</code></li>
<li><code>(false? x)</code></li>
<li><code>(empty? x)</code></li>
<li><code>(= x 5)</code></li></ul></td>
<td>Expression that operates on the parameter.
(... x)</td></tr>
<tr><td><strong>One of</strong>
  <ul><li><code>enum</code></li>
<li><code>union(aka itemization)</code></li></ul></td>
<td></td>
<td>        Cond with one clause per subclass of one of.
<pre><code>(cond [&lt;question1&gt; &lt;answer1&gt;]
      [&lt;question2&gt; &lt;answer2&gt;])</code></pre>

Where each question and answer expression is formed by following the rule in the question or answer column of this table for the corresponding case. A detailed derivation of a template for a one-of type appears below.

Always use else for the last question for itemizations and large enumerations. Normal enumerations should not use else.

Note that in a mixed data itemization, such as

<pre><code>;; Measurement is one of:
;; - "high"
;; - "low"
;; - Number</code></pre>
the cond questions must be guarded with an appropriate type predicate. In particular, the first cond question for Measurement must be

<pre><code>(and (string? m)
     (string=? m "high"))</code></pre>
where the call to string? guards the call to string=?. This will protect string=? from ever receiving a number as an argument.</td></tr>
<tr><td><strong>Compound</strong>
  <ul><li><code>Position</code></li>
<li><code>Firework</code></li>
<li><code>Ball</code></li>
<li><code>cons</code></li>
<li><code>etc</code></li></ul></td>
<td><ul><li><code>(posn? x)</code></li>
<li><code>(firework? x)</code></li>
<li><code>(ball? x)</code></li>
<li><code>(cons? x)</code></li>
<li><code>etc</code></li></ul></td>
<td>All selectors.
<pre><code>(... (posn-x x) (posn-y x))
(... (firework-y x) (firework-color x))
(... (ball-x x) (ball-dx x))
(... (first x) (rest x))
etc.</code></pre>
Then consider the result type of each selector call and wrap the accessor expression appropriately using the table with that type. So for example, if after adding all the selectors you have:
<pre><code>(... (game-ball g) ;produces Ball
     (game-paddle g)) ;produces Paddle</code></pre>
Then, because both Ball and Paddle are non-primitive types (types that you yourself defined in a data definition) the reference rule (immediately below) says that you should add calls to those types' template functions as follows:
<pre><code>(... (fn-for-ball (game-ball g))
     (fn-for-paddle (game-paddle g)))</code></pre></td></tr>
<tr><td><strong>Other Non-Base Type Reference</strong></td>
<td>Predicates come from: define-struct
<ul><li><code>(firework? x)</code></li>
<li><code>(person? x)</code></li></ul></td>
<td>Call to other types template function
<ul><li><code>(fn-for-firework x)</code></li>
<li><code>(fn-for-person x)</code></li></ul></td></tr>
<tr><td><strong>Self Reference</strong></td>
<td></td>
<td>From natural recursion with call to this type's template function
<code>(fn-for-ls (rest ls))</code></td></tr>
<tr><td><strong>Mutal Reference</strong>
Note: form and group all templates in mutual reference cycle together</td>
<td></td>
<td>Call to other type's template function:
<code>(fn-for-lod (dir-subdirs d)</code>
<code>(fn-for-dir (first lod))</code></td></tr></tbody></table>
            </article>
        </main>
    </div>
</body>

</html>